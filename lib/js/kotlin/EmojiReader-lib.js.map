{"version":3,"file":"EmojiReader-lib.js","sources":["generated/_Collections.kt","collections/Collections.kt","kotlin/math.kt","../../../../../lib/src/commonMain/kotlin/com/yy/mobile/emoji/Character.kt","../../../../../lib/src/commonMain/kotlin/com/yy/mobile/emoji/EmojiReader.kt","../../../../../lib/src/commonMain/kotlin/com/yy/mobile/emoji/Integer.kt","../../../../../lib/src/commonMain/kotlin/com/yy/mobile/emoji/StringFactory.kt","../../../../../lib/src/jsMain/kotlin/JsBridge.kt"],"sourcesContent":[null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n",null,null,null,null,null],"names":[],"mappings":"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"}